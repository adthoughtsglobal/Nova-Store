<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta property="og:description" content="Sce.io is a Scenexe-based game, but you go on a single-player journy on killing shapes and becoming giant!"/>
  <meta property="og:image" content="https://media.discordapp.net/attachments/1194914770231504949/1210627756333727794/sce_dot_io.png?ex=65eb3ff5&is=65d8caf5&hm=96b013b064b6c1b9fa70ad5c1ca04c8c5d3a5f85cd7928ba7cb20d3c763c75d1&=&format=webp&quality=lossless&width=494&height=278"/>
  <meta property="og:site_name" content="Sce.io"/>
  <title>Sce.io</title>
  <style>
  html {
  height: 100%;
  width: 100%;
  font-family: Lato;
}
#image {
  position: relative;
  margin: 0;
  padding: 0;
  background-image: url("images/2024_02_17_0ng_Kleki.png");
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  height: 130vh;
  width: 100vw;
  left: -0px;
  top: -120px
}

body {
  overflow: hidden;
}

canvas::-webkit-scrollbar {
  display: none;
}

.menuTitle {
  color: white;
  -webkit-text-stroke: 1px black;
  font-size: 75px;
}

#playButton {
  background: rgb(68, 255, 68);
  border: none;
  border-radius: 2px;
  padding: 5px;
  cursor: pointer;
  transition: all 0.5s;
}

#playButton:hover {
  background: rgb(169, 247, 169);
}
#usernameInput {
  padding: 5px;
  border: 2px solid grey;
  border-radius: 2px;
}

@keyframes menuDown {
  0% {
    bottom: 105%;
    left: 45%;
  }
  100% {
    bottom: 45%;
    left: 45%;
  }
}

#startMenu {
  position: absolute;
  bottom: 45%;
  left: 45%;
  animation: menuDown 3s ease-out;
}
#discord {
  position: absolute;
  bottom: -70%;
  left: -195%;
}
#gameCanvas {
  position: relative;
}
#canvas {
  position: absolute;
  top: -10px;
  left: -50%;
}


#settings {
  position: absolute;
  top: 10px;
  right: 96.5%;
  z-index: 1;
  cursor: pointer;
  user-select: none;
}

#settingsButton {
  padding: 0;
  width: 60px;
  height: 60px;
  cursor: pointer;
  background: #C6C6C6;
  border-radius: 10px;
  border: 5px solid #767676;
  user-select: none;
}
@keyframes settingsHover {
  0% {
    background: #C6C6C6;
    border: 5px solid #767676;
  }
  50% {
    background: #767676;
    border: 5px solid #565656;
  }
  100% {
    background: #C6C6C6;
    border: 5px solid #767676;
  }
}
#settingsButton:hover {
  animation: settingsHover 1s linear infinite;
}

#settingsIcon {
  width: 40px;
  cursor: pointer;
  height: 40px;
  user-select: none;
}

#settingsMenu {
  position: absolute;
  top: 80px;
  right: 90.2%;
  animation-duration: 0.65s;
  animation-timing-function: ease-out;
}
#settingsMenuCover {
  width: 180px;
  height: 360px;
  background: #C6C6C6;
  border-radius: 10px;
  border: 5px solid #767676;
  user-select: none;
}
#settingsTitle {
  position: absolute;
  -webkit-text-fill-color:#767676;
  -webkit-text-stroke: 2px #464646;
  font-size: 30px;
  text-align: center;
  top: -2%;
  left: 8%;
}
#borderVal {
  position: absolute;
  -webkit-text-fill-color:#767676;
  -webkit-text-stroke: 1.4px #464646;
  font-size: 20px;
  text-align: center;
  top: 13%;
  left: 8%;
}
#polygonNumText {
  position: absolute;
  -webkit-text-fill-color:#767676;
  -webkit-text-stroke: 1.4px #464646;
  font-size: 20px;
  text-align: center;
  top: 22.5%;
  left: 8%;
}
#polygonNumInput {
  position: absolute;
  top: 26%;
  left: 66%;
  width: 45px;
  height: 15px;
  background-color: #767676;
  border: 2px solid #464646;
  border-radius: 10px;
  user-select: none;
}
@keyframes slideIn {
  0% {
    right: 101.2%
  }
  100% {
    right: 90.2%
  }
}
@keyframes slideOut {
  0% {
    right: 90.2%
  }
  100% {
    right: 101.2%
  }
}
.slideIn {
  animation-name: slideIn;
}

.slideOut {
  animation-name: slideOut;
}
@keyframes selectorAnimation {
  0% {
    background-color: #767676;
    border: 2px solid #464646;
  }
  50% {
    background-color: #565656;
    border: 2px solid #262626;
  }
  100% {
    background-color: #767676;
    border: 2px solid #464646;
  }
}
#borderSelector {
  position: absolute;
  top: 17%;
  left: 54%;
  width: 75px;
  height: 20px;
  background-color: #767676;
  border: 2px solid #464646;
  border-radius: 10px;
  user-select: none;
}
#borderSelector:hover {
  cursor: pointer;
  animation: selectorAnimation 1s linear infinite;
}
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Lato&family=Montserrat:wght@300&display=swap" rel="stylesheet" />
</head>
<body>
  <img id="image" src="https://media.discordapp.net/attachments/1194914770231504949/1210627837854224434/2024_02_17_0ng_Kleki.png?ex=65eb4008&is=65d8cb08&hm=782200b876a08391d11fe9e8989961381b6e9a8cf3d44103ca1552f1774e64c1&=&format=webp&quality=lossless&width=689&height=402">
  <div id="startMenu">
    <center>
      <h1 class="menuTitle">Sce.io</h1>
      <input type="text" id="usernameInput" placeholder="This is the tale of..." maxlength="23" />
      <button id="playButton">Play</button>
    </center>
    <iframe id="discord" src="https://discord.com/widget?id=1210488110853656606&theme=dark" width="350" height="500" allowtransparency="true" frameborder="0" sandbox="allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts"></iframe>
  </div>
  <div id="gameCanvas">
    <canvas id="canvas"></canvas>
    <div id="settings">
      <button id="settingsButton"><img id="settingsIcon" src="https://media.discordapp.net/attachments/1194914770231504949/1210627902580850749/settingsIcon.png?ex=65eb4018&is=65d8cb18&hm=5a8845642e5c91a49976453a2e847f55f78c3b5428d12e6aad9e7483757cc24b&=&format=webp&quality=lossless&width=393&height=402"></img></button>
    </div>
    <div id="settingsMenu">
      <button id="settingsMenuCover">
        <h1 id="settingsTitle">SETTINGS</h1>
        <h1 id="borderVal">Border:</h1>
        <select name="Border" placeholder="Border" id="borderSelector">
          <option value="normal">Normal</option>
          <option value="classic">Classic</option>
        </select>
        <h1 id="polygonNumText">Max Food: </h1>
        <input id="polygonNumInput" type="number"></input>
      </button>
    </div>
  </div>
  <script src="src/mathFunctions.js"></script>
  <script>
    function greenflag() {
    var canvas = document.getElementById("canvas");
let gameSettings = {
  knockbackPower: 45,
  mapSize: 8192,
  polygons: 175,
  maxPolygonSides: 10 // (works as this: p-3; p is the polygon sides)
};
let gameStarted = false;

document.getElementById("startMenu").style.display = "block";
document.getElementById("gameCanvas").style.display = "none";

let xSmooth = 0;
let ySmooth = 0;
let mousePos = null;
let Acceleration = 0.85;

var ctx = canvas.getContext("2d");

canvas.width = gameSettings.mapSize;
canvas.height = gameSettings.mapSize;
let x = canvas.width;
let y = canvas.height;

var borderTheme = document.getElementById("borderSelector")
var isColoredBorder = true;
let polygonCount = gameSettings.polygons;
setInterval(()=>{
  if (borderTheme.value == "normal") {
    isColoredBorder = true
  } else {
    isColoredBorder = false
  }
},1)

var rarityColors = [
  "FFE46B",
  "FC7676",
  "768CFC",
  "FCA644",
  "38B764",
  "4A66BD",
  "5D275D",
  "1A1C2C",
  "060011",
  "403645",
  "EDEDFF",
];
var borders = [
  "BEAA4E",
  "BF5B5B",
  "5666B9",
  "C68336",
  "2C8C4D",
  "384D90",
  "421C42",
  "000000",
  "000000",
  "352D39",
  "C5C5D4",
];
var teamColors = [
  ["4545FF", "3B3BD9"],
  ["F00000", "BE0000"],
  ["1CE500", "17BD00"],
  ["B55EFF", "8947C1"],
];
var teamColor = [];
var teamBorder = [];
teamColors.forEach((team) => {
  let [teamColor1, teamColor1Border] = teamColors[random(teamColors.length)];
  teamColor.push(teamColor1);
  teamBorder.push(teamColor1Border);
});
class Player {
  constructor(
    id,
    x,
    y,
    size,
    color,
    border,
    speed,
    health,
    maxHealth,
    damage,
    ...guns
  ) {
    this.mouseX = null;
    this.mouseY = null;
    this.id = id;
    this.x = x;
    this.health = health;
    this.maxHealth = maxHealth;
    this.y = y;
    this.size = size;
    this.color = color;
    this.border = border;
    this.speed = speed;
    this.damage = damage;
    this.xp = 0;
    this.neededXP = 100;
    this.totalXP = 0;
    this.level = 1;
    this.keys = {};
    this.isDamaged = false;
    this.healthBarHeight = 20;
    this.angle = 0;
    this.mouseKeys = {};
    this.healthBarWidth = 500;
    if (name === "") {
      name = "Guest " + `#${1000 + Math.floor(Math.random() * 8999)}`;
    }
    this.playerName = name;
    this.guns = guns;
  }
  drawHealthBar(camera) {
    let healthPercentage = this.health / this.maxHealth;
    let healthBarWidth = this.size * 2 * healthPercentage;
    let healthBarX = this.x - this.size - camera.x + camera.width / 2;
    let healthBarY = this.y + this.size + 5 - camera.y + camera.height / 2;

    if (healthPercentage < 0.98) {
      ctx.fillStyle = isColoredBorder ? "#" + this.border : "#000000";
      ctx.fillRect(healthBarX - 2, healthBarY, this.size * 2 + 4, 8);
      ctx.fillStyle = "#" + this.color;
      ctx.fillRect(healthBarX, healthBarY + 2, healthBarWidth, 4);
      ctx.strokeStyle = isColoredBorder ? "#" + this.border : "#000000";
      ctx.strokeRect(healthBarX - 2, healthBarY, this.size * 2 + 4, 8);
    }
  }
  draw(camera) {
    ctx.save();
    ctx.translate(
      this.x - camera.x + camera.width / 2,
      this.y - camera.y + camera.height / 2,
    );
    ctx.rotate(this.angle);

    ctx.beginPath();
    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
    ctx.fillStyle = "#" + this.color;
    ctx.strokeStyle = isColoredBorder ? "#" + this.border : "#000000";
    ctx.lineWidth = 2.5;
    ctx.fill();
    ctx.stroke();
    ctx.closePath();
    ctx.restore();
  }
  guns() {
    this.guns;
  }
  calculateMouseAngle(event) {
    const angle = Math.atan2(
      this.mouseY - (this.y - camera.y + camera.height / 2),
      this.mouseX - (this.x - camera.x + camera.width / 2),
    );

    return angle;
  }
  faceMouse() {
    const angle = this.calculateMouseAngle();
    this.angle = angle;
  }

  move() {
    this.x += xSmooth;
    xSmooth = xSmooth * Acceleration;
    this.y += ySmooth;
    ySmooth = ySmooth * Acceleration;
    if (this.keys["a"] || this.keys["ArrowLeft"] || this.keys["A"]) {
      xSmooth -= this.speed;
    }
    if (this.keys["d"] || this.keys["ArrowRight"] || this.keys["D"]) {
      xSmooth += this.speed;
    }
    if (this.keys["s"] || this.keys["ArrowDown"] || this.keys["S"]) {
      ySmooth += this.speed;
    }
    if (this.keys["w"] || this.keys["ArrowUp"] || this.keys["W"]) {
      ySmooth -= this.speed;
    }
    if (this.keys["e"] || this.keys["E"]) {
      if (this.health < this.maxHealth) {
        this.health += this.maxHealth / 300;
      }
    }
  }
  collideWithWall() {
    if (this.x + this.size >= canvas.width) {
      this.x = canvas.width - this.size;
    }
    if (this.x - this.size < 0) {
      this.x = this.size;
    }
    if (this.y + this.size >= canvas.height) {
      this.y = canvas.height - this.size;
    }
    if (this.y - this.size < 0) {
      this.y = this.size;
    }
  }
  levelUp() {
    if (this.xp >= this.neededXP) {
      this.level++;
      this.xp -= this.neededXP;
      this.neededXP = Math.ceil(this.neededXP * 1.2);
      this.size *= 1.01;
      this.health *= 1.043;
      this.maxHealth *= 1.043;
      this.damage *= 1.043;
      this.playerName = this.playerName;
      this.speed /= 1.01;
    }
    ctx.fillStyle = "white";
    ctx.font = "bold 15px Arial";
    ctx.textAlign = "center";
    ctx.lineWidth = 0.75;
    ctx.strokeStyle = "black";
    ctx.fillText(
      this.playerName,
      this.x - camera.x - this.size + this.size + camera.width / 2,
      this.y - camera.y + this.size + 25 + camera.height / 2,
    );
    ctx.fillText(
      "Lv. " + this.level,
      this.x - camera.x - this.size + this.size + camera.width / 2,
      this.y - camera.y + this.size + 95 + camera.height / 2,
    );
    ctx.fillText(
      "Score: " + this.xp + " / " + this.neededXP,
      this.x - camera.x - this.size + this.size + camera.width / 2,
      this.y - camera.y + this.size + 50 + camera.height / 2,
    );
    ctx.fillText(
      "Total Score: " + this.totalXP,
      this.x - camera.x - this.size + this.size + camera.width / 2,
      this.y - camera.y + this.size + 75 + camera.height / 2,
    );
    ctx.strokeText(
      this.playerName,
      this.x - camera.x - this.size + this.size + camera.width / 2,
      this.y - camera.y + this.size + 25 + camera.height / 2,
    );
    ctx.strokeText(
      "Lv. " + this.level,
      this.x - camera.x - this.size + this.size + camera.width / 2,
      this.y - camera.y + this.size + 95 + camera.height / 2,
    );
    ctx.strokeText(
      "Score: " + this.xp + " / " + this.neededXP,
      this.x - camera.x - this.size + this.size + camera.width / 2,
      this.y - camera.y + this.size + 50 + camera.height / 2,
    );
    ctx.strokeText(
      "Total Score: " + this.totalXP,
      this.x - camera.x - this.size + this.size + camera.width / 2,
      this.y - camera.y + this.size + 75 + camera.height / 2,
    );
  }
}
var ranTeam = random(4);
var player = new Player(
  1,
  canvas.width / 2,
  canvas.height / 2,
  20,
  teamColor[ranTeam],
  teamBorder[ranTeam],
  1,
  800,
  800,
  10,
  [new Gun(canvas.width / 2, canvas.height / 2, 20, 80, 100)],
);
function startGame() {
  document.getElementById("startMenu").style.display = "none";
  document.getElementById("image").style.display = "none";
  document.getElementById("gameCanvas").style.display = "block";

  let usernameInput = document.getElementById("usernameInput");
  var name = usernameInput.value;

  // Update the player's name
  if (name === "" || usernameInput.value.length > 23) {
    name = "Guest " + `#${1000 + Math.floor(Math.random() * 8999)}`;
  }

  player.playerName = name;
  gameStarted = true;
}

document.getElementById("playButton").addEventListener("click", function () {
  startGame();
});

var camera = {
  x: player.x - canvas.width / 2,
  y: player.y - canvas.height / 2,
  width: window.innerWidth,
  height: window.innerHeight / 2,
};
window.addEventListener("resize", ()=>{
  camera.width = window.innerWidth;
  camera.height = window.innerHeight / 2;
  camera.x = player.x - camera.width / 2;
  camera.y = player.y - camera.height / 2;
})
// we need to know the position
canvas.addEventListener("mousemove", function (evt) {
  mousePos = getMousePos(canvas, evt, camera);
});
class Polygon {
  constructor(id, x, y, size, rarity, health, maxHealth, bodyDamage) {
    this.id = id;
    this.x = x;
    this.y = y;
    this.size = size * Math.pow(1.5, rarity);
    this.health = health;
    this.maxHealth = maxHealth;
    this.bodyDamage = bodyDamage;
    this.name = [
      "Triangle",
      "Square",
      "Pentagon",
      "Hexagon",
      "Heptagon",
      "Octagon",
      "Nonagon",
      "Decagon",
      "Hendecagon",
      "Dodecagon",
      "Tridecagon",
      "Tetradecagon",
      "Pentadecagon",
      "Hexadecagon",
      "Heptadecagon",
      "Octadecagon",
      "Enneadecagon",
      "Icosagon",
    ];
    this.colors = rarityColors;
    this.borders = borders;
    this.rarity2 = rarity;
    this.shape = 3 + this.rarity2;
    this.angle = 0;
  }
  draw(camera) {
    ctx.save();
    ctx.translate(
      this.x - camera.x + camera.width / 2,
      this.y - camera.y + camera.height / 2,
    );
    ctx.rotate(this.angle);

    ctx.beginPath();
    ctx.moveTo(this.size * Math.cos(0), this.size * Math.sin(0));

    for (let i = 0; i < this.shape; i++) {
      ctx.lineTo(
        this.size * Math.cos((i * 2 * Math.PI) / this.shape),
        this.size * Math.sin((i * 2 * Math.PI) / this.shape),
      );
    }

    if (this.rarity2 < 11) {
      ctx.fillStyle = "#" + this.colors[this.rarity2];
      ctx.strokeStyle = isColoredBorder ? "#" + this.borders[this.rarity2] : "#000000";
    } else {
      ctx.strokeStyle = "#000000"
      ctx.fillStyle = "#000000";
    }
    ctx.lineWidth = 2.5;
    ctx.fill();
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
    this.drawName(camera);
  }

  update() {
    const centerX = this.x;
    const centerY = this.y;
    const radius = 2 / Math.pow(1.5, this.rarity2);
    const speed = 0.01 / Math.pow(1.5, this.rarity2);
    if (!this.angle) {
      this.angle = Math.random() * 2 * Math.PI;
  }

    this.angle += speed;

    this.x = centerX + radius * Math.cos(this.angle);
    this.y = centerY + radius * Math.sin(this.angle);
  }

  drawName(camera) {
    ctx.fillStyle = "#" + this.colors[this.rarity2];
    ctx.font = "bold 25px Arial";
    ctx.textAlign = "center";
    ctx.strokeStyle = isColoredBorder ? "#" + this.borders[this.rarity2] : "#000000";
    ctx.fillText(
      this.name[this.rarity2],
      this.x - camera.x - this.size + this.size + camera.width / 2,
      this.y - camera.y + this.size + 35 + camera.height / 2,
    );
    ctx.strokeText(
      this.name[this.rarity2],
      this.x - camera.x - this.size + this.size + camera.width / 2,
      this.y - camera.y + this.size + 35 + camera.height / 2,
    );
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  drawHealthBar(camera) {
    let healthPercentage = this.health / this.maxHealth;
    let healthBarWidth = this.size * 2 * healthPercentage;
    let healthBarX = this.x - this.size - camera.x + camera.width / 2;
    let healthBarY = this.y + this.size + 5 - camera.y + camera.height / 2;

    if (healthPercentage < 0.98) {
      ctx.fillStyle = isColoredBorder ? "#" + this.borders[this.rarity2] : "#000000";
      ctx.fillRect(healthBarX - 2, healthBarY, this.size * 2 + 4, 8);
      ctx.fillStyle = "#" + this.colors[this.rarity2];
      ctx.fillRect(healthBarX, healthBarY + 2, healthBarWidth, 4);
      ctx.strokeRect(healthBarX - 2, healthBarY, this.size * 2 + 4, 8);
    }
  }
  collideWithWall() {
    if (this.x + this.size >= canvas.width) {
      this.x = canvas.width - this.size;
    }
    if (this.x - this.size < 0) {
      this.x = this.size;
    }
    if (this.y + this.size >= canvas.height) {
      this.y = canvas.height - this.size;
    }
    if (this.y - this.size < 0) {
      this.y = this.size;
    }
  }
}

let entities = [];
var globalPolygons = 0;
function spawnPolygons() {
  // Main Polygon Loop
  setInterval(() => {
    if (globalPolygons < polygonCount) {
      globalPolygons++;
      var randomRarity = []
      var chances = []
      for (let i = 0; i < gameSettings.maxPolygonSides; i++) {
        randomRarity.push(i)
        chances.push(100 / Math.pow(1.8, i))
      }
      var polygonChosen = randomChance(...chances)
      let polygon = new Polygon(
        1000 + Math.floor(Math.random() * 8999),
        Math.random() * canvas.width,
        Math.random() * canvas.height,
        12.5,
        randomRarity[polygonChosen],
        35 * Math.pow(3.6, randomRarity[polygonChosen]),
        35 * Math.pow(3.6, randomRarity[polygonChosen]),
        10 * Math.pow(1.05, randomRarity[polygonChosen]),
      );
      entities.push(polygon);
    }
  }, 10);
}
spawnPolygons();
document.addEventListener("keydown", function (e) {
  player.keys[e.key] = true;
});

document.addEventListener("keyup", function (e) {
  if (player.keys[e.key]) {
    player.keys[e.key] = false;
  }
});

document.addEventListener("mousemove", function (e) {
  player.mouseX = e.clientX;
  player.mouseY = e.clientY;
  player.calculateMouseAngle(e);
});
function hexToRGBA(hex, alpha) {
  hex = hex.replace("#", "");
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}
function drawGrid(gridSize, color, camera) {
  ctx.beginPath();
  ctx.strokeStyle = color;

  const startX =
    Math.floor((camera.x - camera.width / 2) / gridSize) * gridSize;
  const startY =
    Math.floor((camera.y - camera.height / 2) / gridSize) * gridSize;

  const endX =
    Math.ceil((camera.x + camera.width + camera.width / 2) / gridSize) *
    gridSize;
  const endY =
    Math.ceil((camera.y + camera.height + camera.width / 2) / gridSize) *
    gridSize;

  for (let x = startX; x <= endX; x += gridSize) {
    ctx.moveTo(
      x - camera.x + camera.width / 2,
      startY - camera.y + camera.height / 2,
    );
    ctx.lineTo(
      x - camera.x + camera.width / 2,
      endY - camera.y + camera.height / 2,
    );
  }

  for (let y = startY; y <= endY; y += gridSize) {
    ctx.moveTo(
      startX - camera.x + camera.width / 2,
      y - camera.y + camera.height / 2,
    );
    ctx.lineTo(
      endX - camera.x + camera.width / 2,
      y - camera.y + camera.height / 2,
    );
  }

  ctx.lineWidth = 1;
  ctx.stroke();
}

class Wall {
  constructor(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.w = width;
    this.h = height;
  }
  draw(camera) {
    ctx.fillStyle = "#888888";
    ctx.strokeStyle = isColoredBorder ? "#666666" : "#000000";
    ctx.lineWidth = 3.5;
    ctx.fillRect(
      this.x - camera.x + camera.width / 2,
      this.y - camera.y + camera.height / 2,
      this.w,
      this.h,
    );
    ctx.strokeRect(
      this.x - camera.x + camera.width / 2,
      this.y - camera.y + camera.height / 2,
      this.w,
      this.h,
    );
  }
}
function makeWall(x, y, w, h) {
  return new Wall(x, y, w, h);
}
var walls = [
  makeWall(x / 2, y / 2, 600, 100),
  makeWall(x / 2, y / 2 + 100, 100, 500),
  makeWall(x / 2 + 100, y / 2 + 500, 500, 100),
];

function handleCollision(player, wall) {
  var left1 = player.x - player.size;
  var right1 = player.x + player.size;
  var top1 = player.y - player.size;
  var bottom1 = player.y + player.size;

  var left2 = wall.x;
  var right2 = wall.x + wall.w;
  var top2 = wall.y;
  var bottom2 = wall.y + wall.h;

  if (bottom1 < top2 || top1 > bottom2 || right1 < left2 || left1 > right2) {
    return false;
  } else {
    var overlapX = Math.min(right1 - left2, right2 - left1);
    var overlapY = Math.min(bottom1 - top2, bottom2 - top1);
    if (overlapX < overlapY) {
      if (right1 < right2 && left1 < left2) {
        player.x -= overlapX;
      } else if (right1 > right2 && left1 > left2) {
        player.x += overlapX;
      }
    } else {
      if (bottom1 < bottom2 && top1 < top2) {
        player.y -= overlapY;
      } else if (bottom1 > bottom2 && top1 > top2) {
        player.y += overlapY;
      }
    }
    return true;
  }
}
function getMousePos(canvas, evt, camera) {
  var mouseX = evt.clientX - player.x - camera.x + camera.width;
  var mouseY = evt.clientY - player.y - camera.y + camera.height;
  var camX = camera.x;
  var camY = camera.y;
  mouseX += camX;
  mouseY += camY;
  return {
    x: mouseX,
    y: mouseY,
  };
}

let update = () => {
  if (gameStarted) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGrid(25, "#999999", camera);
    player.draw(camera);
    player.collideWithWall();
    player.levelUp();
    player.drawHealthBar(camera);

    camera.x = player.x - camera.width / 2;
    camera.y = player.y - camera.height / 2;
    entities.forEach((rock) => {
      rock.draw(camera);
      rock.drawHealthBar(camera);
      rock.collideWithWall();
      rock.update();
      camera.x = player.x - camera.width / 2;
      camera.y = player.y - camera.height / 2;
      var distance = Math.sqrt(
        Math.pow(player.x - rock.x, 2) + Math.pow(player.y - rock.y, 2),
      );
      if (distance <= player.size + rock.size) {
        var overlap = player.size + rock.size - distance;
        var angle = Math.atan2(player.y - rock.y, player.x - rock.x);

        player.x += overlap * Math.cos(angle);
        player.y += overlap * Math.sin(angle);
        rock.x -= (overlap * Math.cos(angle)) / rock.size;
        rock.y -= (overlap * Math.sin(angle)) / rock.size;
        rock.health -= player.damage;
        player.health -= rock.bodyDamage;
        player.isDamaged = true;
      }

      for (let i = 0; i < entities.length; i++) {
        const dx = entities[i].x - rock.x;
        const dy = entities[i].y - rock.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const minDistance = rock.size + entities[i].size;

        if (distance < minDistance) {
          const overlap = 0.5 * (distance - minDistance);
          const angle = Math.atan2(dy, dx);
          rock.x += (overlap * Math.cos(angle)) / rock.size;
          rock.y += (overlap * Math.sin(angle)) / rock.size;
          entities[i].x -= (overlap * Math.cos(angle)) / entities[i].size;
          entities[i].y -= (overlap * Math.sin(angle)) / entities[i].size;
        }
      }
      if (rock.health <= 0) {
        entities.splice(entities.indexOf(rock), 1);
        player.xp += 2 * Math.pow(5, rock.shape);
        player.totalXP += 2 * Math.pow(5, rock.shape);
        globalPolygons--;
      }
    });
    walls.forEach((wall) => {
      wall.draw(camera);
      handleCollision(player, wall);
      entities.forEach((rock) => {
        handleCollision(rock, wall);
      });
    });
    player.faceMouse();
    player.move(player.keys);
  }
  requestAnimationFrame(update);
};
update();

    function random(x) {
    return Math.floor(Math.random() * x)
}
    
    var settingsButton = document.getElementById("settingsButton");
var settingsMenu = document.getElementById("settingsMenu");
var settingsOn = false
settingsMenu.style.display = "none"
settingsButton.addEventListener("click", function() {
  settingsOn = !settingsOn
  if (settingsOn) {
    settingsMenu.style.display = "block"
    settingsMenu.classList.add("slideIn")
    settingsMenu.classList.remove("slideOut")
  } else {
    settingsMenu.classList.remove("slideIn")
    settingsMenu.classList.add("slideOut")
    setTimeout(function() {
      settingsMenu.style.display = "none";
    }, 650);
  }
});
    }
  </script>
</body>
</html>
