<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Obama</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <meta name="nova-icon" content="<?xml version='1.0' encoding='UTF-8'?><svg baseProfile='tiny' version='1.2' viewBox='0 0 630 548' xmlns='http://www.w3.org/2000/svg'>[<rect width='629' height='547' fill='#332b29'/>,<g transform='translate(253 211) rotate(173) scale(112 230)'><ellipse rx='1' ry='1' fill='#ffcda1' fill-opacity='.50196'/></g>,<g transform='translate(366 188) rotate(292) scale(46 30)'><ellipse rx='1' ry='1' fill='#ffb469' fill-opacity='.50196'/></g>,<g transform='translate(298 96) rotate(124) scale(38 86)'><ellipse rx='1' ry='1' fill='#ffca9f' fill-opacity='.50196'/></g>,<g transform='translate(49 258) rotate(247) scale(264 115)'><ellipse rx='1' ry='1' fill-opacity='.50196'/></g>,<g transform='translate(165 86) rotate(305) scale(50 27)'><ellipse rx='1' ry='1' fill='#ffc892' fill-opacity='.50196'/></g>,<g transform='translate(526 139) rotate(3) scale(141 409)'><ellipse rx='1' ry='1' fill-opacity='.50196'/></g>,<g transform='translate(165 199) scale(34 79)'><ellipse rx='1' ry='1' fill='#9d5b34' fill-opacity='.50196'/></g>,<g transform='translate(202 468) rotate(275) scale(99 14)'><ellipse rx='1' ry='1' fill='#99c7ff' fill-opacity='.50196'/></g>,<g transform='translate(285 437) scale(29 76)'><ellipse rx='1' ry='1' fill='#7caeff' fill-opacity='.50196'/></g>,<g transform='translate(259 507) rotate(200) scale(28 59)'><ellipse rx='1' ry='1' fill='#5a77b9' fill-opacity='.50196'/></g>,<g transform='translate(480 98) rotate(337) scale(103 381)'><ellipse rx='1' ry='1' fill-opacity='.50196'/></g>,<g transform='translate(324 373) rotate(294) scale(86 17)'><ellipse rx='1' ry='1' fill='#a9e0ff' fill-opacity='.50196'/></g>,<g transform='translate(42 116) rotate(186) scale(92 390)'><ellipse rx='1' ry='1' fill-opacity='.50196'/></g>,<g transform='translate(222 77) rotate(169) scale(73 39)'><ellipse rx='1' ry='1' fill='#ffb480' fill-opacity='.50196'/></g>,<g transform='translate(153 12) rotate(172) scale(357 33)'><ellipse rx='1' ry='1' fill-opacity='.50196'/></g>,<g transform='translate(182 187) rotate(68) scale(18 55)'><ellipse rx='1' ry='1' fill='#ffbf91' fill-opacity='.50196'/></g>,<g transform='translate(198 211) rotate(263) scale(9 36)'><ellipse rx='1' ry='1' fill='#4f0d00' fill-opacity='.50196'/></g>,<g transform='translate(378 273) rotate(175) scale(28 48)'><ellipse rx='1' ry='1' fill-opacity='.50196'/></g>,<g transform='translate(293 213) rotate(312) scale(64 66)'><ellipse rx='1' ry='1' fill='#ffa868' fill-opacity='.50196'/></g>,<g transform='translate(128 475) rotate(306) scale(86 52)'><ellipse rx='1' ry='1' fill='#23344f' fill-opacity='.50196'/></g>,<g transform='translate(568 474) rotate(330) scale(50 70)'><ellipse rx='1' ry='1' fill='#2a3e63' fill-opacity='.50196'/></g>,<g transform='translate(236 358) rotate(238) scale(45 28)'><ellipse rx='1' ry='1' fill='#3a0a00' fill-opacity='.50196'/></g>,<g transform='translate(249 134) rotate(188) scale(39 20)'><ellipse rx='1' ry='1' fill='#320b00' fill-opacity='.50196'/></g>,<g transform='translate(245 297) rotate(118) scale(61 89)'><ellipse rx='1' ry='1' fill='#a15c2c' fill-opacity='.50196'/></g>,<g transform='translate(313 486) scale(16 38)'><ellipse rx='1' ry='1' fill='#06132b' fill-opacity='.50196'/></g>,<g transform='translate(313 381) rotate(125) scale(69 21)'><ellipse rx='1' ry='1' fill='#98b7ff' fill-opacity='.50196'/></g>,<g transform='translate(222 408) rotate(193) scale(26 19)'><ellipse rx='1' ry='1' fill='#6892ff' fill-opacity='.50196'/></g>,<g transform='translate(369 181) rotate(12) scale(29 40)'><ellipse rx='1' ry='1' fill='#ec8a5c' fill-opacity='.50196'/></g>,<g transform='translate(303 39) rotate(299) scale(21 65)'><ellipse rx='1' ry='1' fill='#877769' fill-opacity='.50196'/></g>,<g transform='translate(174 328) rotate(155) scale(8 56)'><ellipse rx='1' ry='1' fill-opacity='.50196'/></g>,<g transform='translate(258 432) rotate(134) scale(11 36)'><ellipse rx='1' ry='1' fill-opacity='.50196'/></g>,<g transform='translate(207 45) rotate(265) scale(21 56)'><ellipse rx='1' ry='1' fill='#c27e4a' fill-opacity='.50196'/></g>,<g transform='translate(372 262) rotate(70) scale(31 22)'><ellipse rx='1' ry='1' fill-opacity='.50196'/></g>,<g transform='translate(146 153) rotate(70) scale(20 49)'><ellipse rx='1' ry='1' fill='#130b02' fill-opacity='.50196'/></g>,<g transform='translate(156 340) rotate(217) scale(47 32)'><ellipse rx='1' ry='1' fill-opacity='.50196'/></g>,<g transform='translate(298 445) rotate(-46) scale(11)'><ellipse rx='1' ry='1' fill='#b6c1ff' fill-opacity='.50196'/></g>,<g transform='translate(13 388) rotate(148) scale(179 75)'><ellipse rx='1' ry='1' fill-opacity='.50196'/></g>,<g transform='translate(429 290) rotate(309) scale(64 86)'><ellipse rx='1' ry='1' fill-opacity='.50196'/></g>,<g transform='translate(394 38) rotate(240) scale(524 43)'><ellipse rx='1' ry='1' fill-opacity='.50196'/></g>]</svg>">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }

        .canvas-container {
            width: 100%;
            padding-bottom: 75%;
            position: relative;
            background-color: #e2e8f0;
            border: 2px dashed #94a3b8;
            border-radius: 0.75rem;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
    </style>
</head>

<body class="p-4 md:p-8">

    <div class="max-w-6xl mx-auto">
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
            <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-xl font-semibold mb-4 text-indigo-600">Source Image</h2>
                <input type="file" id="sourceImageInput" accept="image/*"
                    class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 cursor-pointer">
                <div class="mt-4 canvas-container">
                    <canvas id="sourceCanvas" class="rounded-lg"></canvas>
                </div>
            </div>

            <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200" style="display: none;">
                <h2 class="text-xl font-semibold mb-4 text-pink-600">2. Fixed Target Image (Barack Obama Portrait)</h2>
                <div class="text-sm text-gray-500 mb-4">Pixels from your image will rearrange to match the luminance
                    pattern of this image.</div>
                <div class="canvas-container">
                    <canvas id="targetCanvas" class="rounded-lg"></canvas>
                </div>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mb-8">
            <button id="rearrangeButton"
                class="w-full sm:w-auto px-8 py-3 bg-indigo-500 text-white font-bold rounded-full shadow-lg hover:bg-indigo-600 transition duration-150 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
                disabled>
                <svg id="spinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden"
                    xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                    </path>
                </svg>
                Generate
            </button>
            <div id="statusMessage" class="text-sm text-gray-600 p-2 rounded-lg">
                Loading target image...
            </div>
        </div>

        <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-indigo-100">
            <h2 class="text-2xl font-bold mb-4 text-center text-gray-800">3. Animated Result</h2>
            <div class="canvas-container !padding-bottom-100%" id="resultContainer">
                <canvas id="resultCanvas" class="rounded-lg border border-gray-300"></canvas>
                <div id="resultPlaceholder"
                    class="absolute inset-0 flex items-center justify-center text-gray-400 text-lg font-medium bg-gray-50 rounded-lg">
                    Result will appear here...
                </div>
            </div>
        </div>
    </div>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        };

        const $ = selector => document.querySelector(selector);

        const targetImageUrl = 'https://i.ibb.co/qFcTRqrv/image.png';

        const sourceInput = $('#sourceImageInput');
        const rearrangeButton = $('#rearrangeButton');
        const statusMessage = $('#statusMessage');
        const spinner = $('#spinner');
        const resultPlaceholder = $('#resultPlaceholder');

        const sourceCanvas = $('#sourceCanvas');
        const targetCanvas = $('#targetCanvas');
        const resultCanvas = $('#resultCanvas');

        let sourceImageData = null;
        let targetImageData = null;
        let isProcessing = false;
        let animationId = null;

        const PROCESSING_RESOLUTION = 100;
        const ANIMATION_DURATION = 3000;
        const INITIAL_HOLD_DURATION = 1000; // ðŸ‘ˆ New constant for 1 second hold

        let pixelMap = null;

        const getLuminance = (r, g, b) => (0.2126 * r + 0.7152 * g + 0.0722 * b);

        const getPixelData = (imageData) => {
            const data = imageData.data;
            const pixels = [];
            const pixelCount = data.length / 4;
            const width = imageData.width;

            for (let i = 0; i < pixelCount; i++) {
                const index = i * 4;
                const r = data[index];
                const g = data[index + 1];
                const b = data[index + 2];
                const a = data[index + 3];
                const luminance = getLuminance(r, g, b);
                const x = i % width;
                const y = Math.floor(i / width);

                pixels.push({ r, g, b, a, luminance, x, y, originalIndex: index });
            }
            return pixels;
        };

        const resizeImageData = (imageData, newWidth, newHeight) => {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = newWidth;
            tempCanvas.height = newHeight;

            const originalCanvas = document.createElement('canvas');
            const originalCtx = originalCanvas.getContext('2d');
            originalCanvas.width = imageData.width;
            originalCanvas.height = imageData.height;
            originalCtx.putImageData(imageData, 0, 0);

            tempCtx.drawImage(originalCanvas, 0, 0, newWidth, newHeight);
            return tempCtx.getImageData(0, 0, newWidth, newHeight);
        };

        const loadImageAndDisplay = (source, canvas, callback) => {
            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.crossOrigin = "Anonymous";

            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;

                const container = canvas.parentElement;
                container.style.paddingBottom = `${(img.height / img.width) * 100}%`;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                const originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                callback(originalImageData);
            };
            img.onerror = () => {
                setStatus('Error loading image. Check network and CORS settings.', 'text-red-600 bg-red-50');
                callback(null);
            };

            if (typeof source === 'string') {
                img.src = source;
            } else if (source instanceof File) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    img.src = event.target.result;
                };
                reader.readAsDataURL(source);
            }
        };

        const setStatus = (message, colorClass = 'text-gray-600') => {
            statusMessage.textContent = message;
            statusMessage.className = `text-sm p-2 rounded-lg ${colorClass}`;
        };

        const updateButtonState = () => {
            const ready = sourceImageData && targetImageData && !isProcessing;
            rearrangeButton.disabled = !ready;
            if (ready) {
                setStatus('Ready to generate! Click the button.', 'text-green-600 bg-green-50');
            } else if (!sourceImageData) {
                setStatus('Please upload your source image.', 'text-gray-600');
            } else if (!targetImageData) {
                setStatus('Loading target image...', 'text-gray-600');
            } else if (isProcessing) {
                setStatus('Processing image...', 'text-indigo-600 bg-indigo-50');
            }
        };

        // ðŸ‘ˆ Modified function
        const animateRearrangement = (timestamp, startTime, map, ctx, width) => {
            // Calculate the elapsed time relative to the start of the whole process
            const elapsed = timestamp - startTime;

            // The hold phase lasts for INITIAL_HOLD_DURATION
            if (elapsed < INITIAL_HOLD_DURATION) {
                // During the hold phase, progress is 0, so the pixel position is always at startX/startY
                const progress = 0;
                const resultImageData = ctx.createImageData(width, width);
                const resultData = resultImageData.data;

                map.forEach(pixel => {
                    const index = (pixel.startY * width + pixel.startX) * 4; // Use start position

                    resultData[index] = pixel.r;
                    resultData[index + 1] = pixel.g;
                    resultData[index + 2] = pixel.b;
                    resultData[index + 3] = pixel.a;
                });

                ctx.putImageData(resultImageData, 0, 0);
                setStatus(`Initial image hold: ${Math.round(elapsed / 100) * 100}ms / ${INITIAL_HOLD_DURATION}ms`, 'text-indigo-600 bg-indigo-50');
                animationId = requestAnimationFrame(ts => animateRearrangement(ts, startTime, map, ctx, width));
                return;
            }

            // The animation phase starts after the initial hold
            const animationElapsed = elapsed - INITIAL_HOLD_DURATION;
            const progress = Math.min(animationElapsed / ANIMATION_DURATION, 1);

            ctx.clearRect(0, 0, width, width);

            const resultImageData = ctx.createImageData(width, width);
            const resultData = resultImageData.data;

            const lerp = (start, end, t) => start + (end - start) * t;

            map.forEach(pixel => {
                const currentX = Math.round(lerp(pixel.startX, pixel.endX, progress));
                const currentY = Math.round(lerp(pixel.startY, pixel.endY, progress));

                const index = (currentY * width + currentX) * 4;

                resultData[index] = pixel.r;
                resultData[index + 1] = pixel.g;
                resultData[index + 2] = pixel.b;
                resultData[index + 3] = pixel.a;
            });

            ctx.putImageData(resultImageData, 0, 0);

            if (progress < 1) {
                setStatus(`Animating... ${Math.round(progress * 100)}% complete`, 'text-indigo-600 bg-indigo-50');
                animationId = requestAnimationFrame(ts => animateRearrangement(ts, startTime, map, ctx, width));
            } else {
                setStatus(`Animation complete! (${(INITIAL_HOLD_DURATION + ANIMATION_DURATION) / 1000} seconds total)`, 'text-green-600 bg-green-50');
                isProcessing = false;
                updateButtonState();
            }
        };

        // ðŸ‘ˆ Modified function
        const processImages = () => {
            if (isProcessing || !sourceImageData || !targetImageData) return;

            if (animationId) cancelAnimationFrame(animationId);

            isProcessing = true;
            updateButtonState();
            spinner.classList.remove('hidden');
            resultPlaceholder.classList.add('hidden');

            const outputWidth = PROCESSING_RESOLUTION;
            const outputHeight = PROCESSING_RESOLUTION;
            resultCanvas.width = outputWidth;
            resultCanvas.height = outputHeight;
            const resultCtx = resultCanvas.getContext('2d');

            const container = resultCanvas.parentElement;
            container.style.paddingBottom = `${(outputHeight / outputWidth) * 100}%`;

            setStatus(`Resizing images to ${PROCESSING_RESOLUTION}x${PROCESSING_RESOLUTION} and mapping pixels...`, 'text-indigo-600 bg-indigo-50');

            setTimeout(() => {
                try {
                    const processedSourceImageData = resizeImageData(sourceImageData, outputWidth, outputHeight);
                    const processedTargetImageData = resizeImageData(targetImageData, outputWidth, outputHeight);

                    const sourcePixels = getPixelData(processedSourceImageData);
                    const targetPixels = getPixelData(processedTargetImageData);

                    setStatus('Sorting pixels by luminance (brightness) to create the movement map...', 'text-indigo-600 bg-indigo-50');

                    sourcePixels.sort((a, b) => a.luminance - b.luminance);
                    targetPixels.sort((a, b) => a.luminance - b.luminance);

                    pixelMap = sourcePixels.map((sourcePixel, i) => {
                        const targetPosition = targetPixels[i];
                        return {
                            r: sourcePixel.r,
                            g: sourcePixel.g,
                            b: sourcePixel.b,
                            a: sourcePixel.a,
                            startX: sourcePixel.x,
                            startY: sourcePixel.y,
                            endX: targetPosition.x,
                            endY: targetPosition.y,
                        };
                    });

                    // Set initial status for the hold phase
                    setStatus('Starting 1-second initial image hold...', 'text-indigo-600 bg-indigo-50');
                    spinner.classList.add('hidden');
                    updateButtonState();
                    isProcessing = false;

                    const startTime = performance.now();
                    // Start the animation, which now includes the hold phase
                    animationId = requestAnimationFrame(ts => animateRearrangement(ts, startTime, pixelMap, resultCtx, outputWidth));

                } catch (error) {
                    console.error("Processing error:", error);
                    setStatus('An unexpected error occurred during processing.', 'text-red-600 bg-red-50');
                    isProcessing = false;
                    spinner.classList.add('hidden');
                    updateButtonState();
                }
            }, 50);
        };

        sourceInput.addEventListener('change', (event) => {
            if (event.target.files.length > 0) {
                loadImageAndDisplay(event.target.files[0], sourceCanvas, (data) => {
                    sourceImageData = data;
                    updateButtonState();
                });
            } else {
                sourceImageData = null;
                updateButtonState();
            }
        });

        rearrangeButton.addEventListener('click', processImages);

        // Load the fixed target image automatically on startup
        window.addEventListener('load', () => {
            loadImageAndDisplay(targetImageUrl, targetCanvas, (data) => {
                targetImageData = data;
                if (!targetImageData) {
                    setStatus('Failed to load fixed target image.', 'text-red-600 bg-red-50');
                }
                updateButtonState();
            });
        });

    </script>
</body>

</html>